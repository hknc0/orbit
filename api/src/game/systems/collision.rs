use crate::game::constants::{collision::*, mass::*, spawn::RESPAWN_DELAY};
use crate::game::state::{GameState, PlayerId};
use crate::util::vec2::Vec2;

/// Events generated by collision resolution
#[derive(Debug, Clone)]
pub enum CollisionEvent {
    /// Player killed another player
    Kill {
        killer_id: PlayerId,
        victim_id: PlayerId,
    },
    /// Player collected a projectile
    ProjectileAbsorbed {
        player_id: PlayerId,
        projectile_id: u64,
        mass_gained: f32,
    },
    /// Player collected debris
    DebrisCollected {
        player_id: PlayerId,
        debris_id: u64,
        mass_gained: f32,
    },
    /// Elastic collision (both survived)
    Deflection {
        player_a: PlayerId,
        player_b: PlayerId,
    },
}

/// Update collision detection and resolution
pub fn update(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();

    // Player-player collisions
    events.extend(update_player_collisions(state));

    // Player-projectile collisions
    events.extend(update_projectile_collisions(state));

    // Player-debris collisions
    events.extend(update_debris_collisions(state));

    events
}

/// Handle player-player collisions using momentum-based resolution
fn update_player_collisions(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();
    let player_count = state.players.len();

    for i in 0..player_count {
        for j in (i + 1)..player_count {
            // Skip if either player is dead
            if !state.players[i].alive || !state.players[j].alive {
                continue;
            }

            // Skip if either player has spawn protection
            if state.players[i].spawn_protection > 0.0 || state.players[j].spawn_protection > 0.0 {
                continue;
            }

            let radius_i = mass_to_radius(state.players[i].mass);
            let radius_j = mass_to_radius(state.players[j].mass);
            let dist = state.players[i]
                .position
                .distance_to(state.players[j].position);

            if dist < radius_i + radius_j {
                if let Some(event) = resolve_player_collision(state, i, j) {
                    events.push(event);
                }
            }
        }
    }

    events
}

/// Resolve collision between two players using momentum-based outcome
fn resolve_player_collision(
    state: &mut GameState,
    idx_a: usize,
    idx_b: usize,
) -> Option<CollisionEvent> {
    let delta = state.players[idx_b].position - state.players[idx_a].position;
    let dist = delta.length();

    if dist == 0.0 {
        return None;
    }

    let normal = delta * (1.0 / dist);

    // Calculate approach momentum along collision normal
    // Only count velocity component moving toward the other player
    let vel_a_toward = state.players[idx_a].velocity.dot(normal).max(0.0);
    let vel_b_toward = (-state.players[idx_b].velocity.dot(normal)).max(0.0);

    let momentum_a = state.players[idx_a].mass * vel_a_toward;
    let momentum_b = state.players[idx_b].mass * vel_b_toward;

    // If neither is moving toward the other, just deflect
    if momentum_a == 0.0 && momentum_b == 0.0 {
        deflect(state, idx_a, idx_b, normal);
        return None;
    }

    let ratio = if momentum_b == 0.0 {
        f32::INFINITY
    } else {
        momentum_a / momentum_b
    };

    // Determine outcome based on momentum ratio
    if ratio > OVERWHELM_THRESHOLD {
        // A overwhelms B - clean kill
        let mass_gain = (state.players[idx_b].mass * ABSORPTION_RATE).min(ABSORPTION_CAP);
        let killer_id = state.players[idx_a].id;
        let victim_id = state.players[idx_b].id;

        state.players[idx_b].alive = false;
        state.players[idx_b].deaths += 1;
        state.players[idx_b].respawn_timer = RESPAWN_DELAY;
        state.players[idx_a].kills += 1;
        state.players[idx_a].mass += mass_gain;

        Some(CollisionEvent::Kill {
            killer_id,
            victim_id,
        })
    } else if ratio > DECISIVE_THRESHOLD {
        // A decisively wins - kill with splash damage cost
        let mass_gain = (state.players[idx_b].mass * 0.5).min(ABSORPTION_CAP);
        let killer_id = state.players[idx_a].id;
        let victim_id = state.players[idx_b].id;

        state.players[idx_b].alive = false;
        state.players[idx_b].deaths += 1;
        state.players[idx_b].respawn_timer = RESPAWN_DELAY;
        state.players[idx_a].kills += 1;
        state.players[idx_a].mass = state.players[idx_a].mass * 0.8 + mass_gain;

        Some(CollisionEvent::Kill {
            killer_id,
            victim_id,
        })
    } else if ratio > 1.0 / DECISIVE_THRESHOLD {
        // Close fight - both survive but lose mass
        deflect(state, idx_a, idx_b, normal);

        // Winner loses less mass
        if ratio > 1.0 {
            state.players[idx_a].mass *= 0.7;
            state.players[idx_b].mass *= 0.75;
        } else {
            state.players[idx_a].mass *= 0.75;
            state.players[idx_b].mass *= 0.7;
        }

        // Check for death by minimum mass
        check_min_mass(state, idx_a);
        check_min_mass(state, idx_b);

        Some(CollisionEvent::Deflection {
            player_a: state.players[idx_a].id,
            player_b: state.players[idx_b].id,
        })
    } else if ratio > 1.0 / OVERWHELM_THRESHOLD {
        // B decisively wins
        let mass_gain = (state.players[idx_a].mass * 0.5).min(ABSORPTION_CAP);
        let killer_id = state.players[idx_b].id;
        let victim_id = state.players[idx_a].id;

        state.players[idx_a].alive = false;
        state.players[idx_a].deaths += 1;
        state.players[idx_a].respawn_timer = RESPAWN_DELAY;
        state.players[idx_b].kills += 1;
        state.players[idx_b].mass = state.players[idx_b].mass * 0.8 + mass_gain;

        Some(CollisionEvent::Kill {
            killer_id,
            victim_id,
        })
    } else {
        // B overwhelms A - clean kill
        let mass_gain = (state.players[idx_a].mass * ABSORPTION_RATE).min(ABSORPTION_CAP);
        let killer_id = state.players[idx_b].id;
        let victim_id = state.players[idx_a].id;

        state.players[idx_a].alive = false;
        state.players[idx_a].deaths += 1;
        state.players[idx_a].respawn_timer = RESPAWN_DELAY;
        state.players[idx_b].kills += 1;
        state.players[idx_b].mass += mass_gain;

        Some(CollisionEvent::Kill {
            killer_id,
            victim_id,
        })
    }
}

/// Apply elastic deflection between two players
fn deflect(state: &mut GameState, a: usize, b: usize, normal: Vec2) {
    let rel_vel = state.players[a].velocity - state.players[b].velocity;
    let rel_n = rel_vel.dot(normal);

    // Only deflect if moving toward each other
    if rel_n > 0.0 {
        return;
    }

    let (m_a, m_b) = (state.players[a].mass, state.players[b].mass);

    // Calculate impulse magnitude using coefficient of restitution
    let j = (-(1.0 + RESTITUTION) * rel_n) / (1.0 / m_a + 1.0 / m_b);
    let impulse = normal * j;

    // Apply impulses
    state.players[a].velocity += impulse * (1.0 / m_a);
    state.players[b].velocity -= impulse * (1.0 / m_b);

    // Separate overlapping bodies
    let (r_a, r_b) = (mass_to_radius(m_a), mass_to_radius(m_b));
    let dist = (state.players[a].position - state.players[b].position).length();
    let overlap = r_a + r_b - dist;

    if overlap > 0.0 {
        let sep = overlap / 2.0 + 1.0;
        state.players[a].position -= normal * sep;
        state.players[b].position += normal * sep;
    }
}

/// Check if player mass is below minimum and kill if so
fn check_min_mass(state: &mut GameState, idx: usize) {
    if state.players[idx].mass < MINIMUM {
        state.players[idx].alive = false;
        state.players[idx].deaths += 1;
        state.players[idx].respawn_timer = RESPAWN_DELAY;
    }
}

/// Handle player-projectile collisions
fn update_projectile_collisions(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();
    let mut projectiles_to_remove = Vec::new();

    for (proj_idx, projectile) in state.projectiles.iter().enumerate() {
        let proj_radius = mass_to_radius(projectile.mass);

        for player in &mut state.players {
            if !player.alive {
                continue;
            }

            // Can't absorb own projectile immediately
            if player.id == projectile.owner_id && projectile.lifetime > 7.5 {
                continue;
            }

            let player_radius = mass_to_radius(player.mass);
            let dist = player.position.distance_to(projectile.position);

            if dist < player_radius + proj_radius {
                // Player absorbs projectile
                let mass_gain = projectile.mass.min(ABSORPTION_CAP);
                player.mass += mass_gain;

                events.push(CollisionEvent::ProjectileAbsorbed {
                    player_id: player.id,
                    projectile_id: projectile.id,
                    mass_gained: mass_gain,
                });

                projectiles_to_remove.push(proj_idx);
                break;
            }
        }
    }

    // Remove absorbed projectiles (in reverse order to maintain indices)
    for idx in projectiles_to_remove.into_iter().rev() {
        state.projectiles.remove(idx);
    }

    events
}

/// Handle player-debris collisions
fn update_debris_collisions(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();
    let mut debris_to_remove = Vec::new();

    for (debris_idx, debris) in state.debris.iter().enumerate() {
        let debris_radius = debris.radius();

        for player in &mut state.players {
            if !player.alive {
                continue;
            }

            let player_radius = mass_to_radius(player.mass);
            let dist = player.position.distance_to(debris.position);

            if dist < player_radius + debris_radius {
                // Player collects debris
                let mass_gain = debris.mass();
                player.mass += mass_gain;

                events.push(CollisionEvent::DebrisCollected {
                    player_id: player.id,
                    debris_id: debris.id,
                    mass_gained: mass_gain,
                });

                debris_to_remove.push(debris_idx);
                break;
            }
        }
    }

    // Remove collected debris
    for idx in debris_to_remove.into_iter().rev() {
        state.debris.remove(idx);
    }

    events
}

/// Calculate radius from mass
#[inline]
pub fn mass_to_radius(mass: f32) -> f32 {
    mass.sqrt() * RADIUS_SCALE
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::game::state::{DebrisSize, Player};

    fn create_player(id: &str, position: Vec2, velocity: Vec2, mass: f32) -> Player {
        Player {
            id: uuid::Uuid::new_v4(),
            name: id.to_string(),
            position,
            velocity,
            rotation: 0.0,
            mass,
            alive: true,
            kills: 0,
            deaths: 0,
            spawn_protection: 0.0,
            is_bot: false,
            color_index: 0,
            respawn_timer: 0.0,
        }
    }

    #[test]
    fn test_no_collision_when_far_apart() {
        let mut state = GameState::new();
        state.add_player(create_player("A", Vec2::new(0.0, 0.0), Vec2::ZERO, 100.0));
        state.add_player(create_player("B", Vec2::new(1000.0, 0.0), Vec2::ZERO, 100.0));

        let events = update(&mut state);

        assert!(events.is_empty());
        assert!(state.players[0].alive);
        assert!(state.players[1].alive);
    }

    #[test]
    fn test_overwhelm_collision() {
        let mut state = GameState::new();

        // Player A: heavy and moving fast toward B
        state.add_player(create_player(
            "A",
            Vec2::new(0.0, 0.0),
            Vec2::new(200.0, 0.0),
            200.0,
        ));

        // Player B: light and stationary
        state.add_player(create_player(
            "B",
            Vec2::new(30.0, 0.0), // Close enough to collide
            Vec2::ZERO,
            50.0,
        ));

        let events = update(&mut state);

        assert!(events.iter().any(|e| matches!(e, CollisionEvent::Kill { .. })));
        assert!(state.players[0].alive); // A survives
        assert!(!state.players[1].alive); // B dies
        assert!(state.players[0].mass > 200.0); // A gained mass
    }

    #[test]
    fn test_spawn_protection_prevents_collision() {
        let mut state = GameState::new();

        let mut p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), 200.0);
        p1.spawn_protection = 3.0;
        state.add_player(p1);

        state.add_player(create_player(
            "B",
            Vec2::new(30.0, 0.0),
            Vec2::ZERO,
            50.0,
        ));

        let events = update(&mut state);

        assert!(events.is_empty());
        assert!(state.players[0].alive);
        assert!(state.players[1].alive);
    }

    #[test]
    fn test_deflection_both_survive() {
        let mut state = GameState::new();

        // Two equal players moving toward each other at same speed
        state.add_player(create_player(
            "A",
            Vec2::new(0.0, 0.0),
            Vec2::new(50.0, 0.0),
            100.0,
        ));

        state.add_player(create_player(
            "B",
            Vec2::new(30.0, 0.0),
            Vec2::new(-50.0, 0.0),
            100.0,
        ));

        let events = update(&mut state);

        // Should be a deflection, both survive
        assert!(events
            .iter()
            .any(|e| matches!(e, CollisionEvent::Deflection { .. })));
        // Note: mass loss might cause death if below minimum
    }

    #[test]
    fn test_projectile_absorption() {
        let mut state = GameState::new();

        let player = create_player("A", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let player_id = player.id;
        state.add_player(player);

        // Add projectile from different owner at same position
        state.add_projectile(
            uuid::Uuid::new_v4(), // Different owner
            Vec2::new(100.0, 100.0),
            Vec2::ZERO,
            20.0,
        );
        // Set lifetime lower so it can be absorbed
        state.projectiles[0].lifetime = 5.0;

        let initial_mass = state.players[0].mass;
        let events = update(&mut state);

        assert!(events
            .iter()
            .any(|e| matches!(e, CollisionEvent::ProjectileAbsorbed { .. })));
        assert!(state.projectiles.is_empty());
        assert!(state.players[0].mass > initial_mass);
    }

    #[test]
    fn test_own_projectile_not_absorbed_immediately() {
        let mut state = GameState::new();

        let player = create_player("A", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let player_id = player.id;
        state.add_player(player);

        // Add projectile from same owner with high lifetime
        state.add_projectile(player_id, Vec2::new(100.0, 100.0), Vec2::ZERO, 20.0);

        let initial_mass = state.players[0].mass;
        let events = update(&mut state);

        // Should not absorb own fresh projectile
        assert!(!events
            .iter()
            .any(|e| matches!(e, CollisionEvent::ProjectileAbsorbed { .. })));
    }

    #[test]
    fn test_debris_collection() {
        let mut state = GameState::new();

        state.add_player(create_player(
            "A",
            Vec2::new(100.0, 100.0),
            Vec2::ZERO,
            100.0,
        ));

        state.add_debris(Vec2::new(100.0, 100.0), Vec2::ZERO, DebrisSize::Medium);

        let initial_mass = state.players[0].mass;
        let events = update(&mut state);

        assert!(events
            .iter()
            .any(|e| matches!(e, CollisionEvent::DebrisCollected { .. })));
        assert!(state.debris.is_empty());
        assert!(state.players[0].mass > initial_mass);
    }

    #[test]
    fn test_mass_to_radius() {
        let mass = 100.0;
        let radius = mass_to_radius(mass);
        let expected = (100.0_f32).sqrt() * RADIUS_SCALE;

        assert!((radius - expected).abs() < 0.001);
    }

    #[test]
    fn test_collision_determinism() {
        // Same initial conditions should produce same results
        let create_state = || {
            let mut state = GameState::new();
            state.add_player(create_player(
                "A",
                Vec2::new(0.0, 0.0),
                Vec2::new(100.0, 0.0),
                150.0,
            ));
            state.add_player(create_player(
                "B",
                Vec2::new(30.0, 0.0),
                Vec2::new(-50.0, 0.0),
                100.0,
            ));
            state
        };

        let mut state1 = create_state();
        let mut state2 = create_state();

        let events1 = update(&mut state1);
        let events2 = update(&mut state2);

        assert_eq!(events1.len(), events2.len());
        assert_eq!(state1.players[0].alive, state2.players[0].alive);
        assert_eq!(state1.players[1].alive, state2.players[1].alive);
    }

    #[test]
    fn test_dead_players_ignored() {
        let mut state = GameState::new();

        let mut p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), 200.0);
        p1.alive = false;
        state.add_player(p1);

        state.add_player(create_player(
            "B",
            Vec2::new(30.0, 0.0),
            Vec2::ZERO,
            100.0,
        ));

        let events = update(&mut state);

        assert!(events.is_empty());
    }
}
