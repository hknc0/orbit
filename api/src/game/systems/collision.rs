//! Collision detection and resolution
//!
//! Handles player-player, player-projectile, and player-debris collisions.
//!
//! With `advanced_physics` feature: uses momentum and kinetic energy helpers
//! for more accurate collision calculations.

#![allow(dead_code)] // Collision event fields and helpers

use crate::game::constants::{collision::*, mass::*, spawn::RESPAWN_DELAY};
use crate::game::spatial::{SpatialEntity, SpatialEntityId, SpatialGrid, ENTITY_GRID_CELL_SIZE};
use crate::game::state::{GameState, PlayerId};
use crate::util::vec2::Vec2;

// ============================================================================
// Collision Detection Constants
// ============================================================================

/// Epsilon for numerical stability in distance checks (prevents division by near-zero)
const COLLISION_DISTANCE_EPSILON: f32 = 0.001;

/// Mass gain multiplier for decisive collision winner (slightly less than full absorption)
const DECISIVE_COLLISION_MASS_GAIN_RATIO: f32 = 0.5;

/// Mass retention for decisive collision winner (slight cost for winning)
const DECISIVE_COLLISION_WINNER_MASS_RETENTION: f32 = 0.8;

/// Mass retention for close fight winner
const CLOSE_FIGHT_WINNER_MASS_RETENTION: f32 = 0.7;

/// Mass retention for close fight loser
const CLOSE_FIGHT_LOSER_MASS_RETENTION: f32 = 0.75;

/// Relative velocity threshold for collision intensity normalization
/// At this velocity, intensity reaches 1.0
const COLLISION_INTENSITY_MAX_VELOCITY: f32 = 200.0;

/// Cell size for debris collision spatial grid
const DEBRIS_COLLISION_GRID_CELL_SIZE: f32 = 32.0;

/// Maximum debris radius for query padding
const DEBRIS_QUERY_MAX_RADIUS: f32 = 15.0;

/// Projectile lifetime threshold for owner absorption (can absorb own projectile after this time)
const PROJECTILE_OWNER_ABSORPTION_LIFETIME_THRESHOLD: f32 = 7.5;

// Feature-gated physics helpers
#[cfg(feature = "advanced_physics")]
use crate::game::systems::physics::{kinetic_energy, momentum_magnitude};

/// Events generated by collision resolution
#[derive(Debug, Clone)]
pub enum CollisionEvent {
    /// Player killed another player
    Kill {
        killer_id: PlayerId,
        victim_id: PlayerId,
    },
    /// Player collected a projectile
    ProjectileAbsorbed {
        player_id: PlayerId,
        projectile_id: u64,
        mass_gained: f32,
    },
    /// Player collected debris
    DebrisCollected {
        player_id: PlayerId,
        debris_id: u64,
        mass_gained: f32,
    },
    /// Elastic collision (both survived)
    Deflection {
        player_a: PlayerId,
        player_b: PlayerId,
        /// Midpoint of collision for visual effects
        position: Vec2,
        /// Intensity 0-1 based on relative velocity (for effect scaling)
        intensity: f32,
    },
}

/// Update collision detection and resolution
pub fn update(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();

    // Player-player collisions
    events.extend(update_player_collisions(state));

    // Player-projectile collisions
    events.extend(update_projectile_collisions(state));

    // Player-debris collisions
    events.extend(update_debris_collisions(state));

    events
}

/// Handle player-player collisions using spatial grid for O(n) performance
fn update_player_collisions(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();

    // Build spatial grid with players (O(n))
    // Cell size of 64 units covers typical player radii (10-30)
    let mut grid = SpatialGrid::new(ENTITY_GRID_CELL_SIZE);

    // Insert players into grid (no need to collect, just iterate)
    for player in state.players.values() {
        if player.alive && player.spawn_protection <= 0.0 {
            let radius = mass_to_radius(player.mass);
            grid.insert(SpatialEntity {
                id: SpatialEntityId::Player(player.id),
                position: player.position,
                radius,
            });
        }
    }

    // Use spatial grid to get potential collision pairs (O(n) average)
    // This dramatically reduces checks from n² to ~n for sparse distributions
    let pairs = grid.get_potential_collisions();

    for (entity_a, entity_b) in pairs {
        // Extract player IDs
        let (id_a, id_b) = match (entity_a.id, entity_b.id) {
            (SpatialEntityId::Player(a), SpatialEntityId::Player(b)) => (a, b),
            _ => continue, // Skip non-player pairs
        };

        // Squared distance check to avoid sqrt()
        let dist_sq = entity_a.position.distance_sq_to(entity_b.position);
        let combined_radius = entity_a.radius + entity_b.radius;

        if dist_sq < combined_radius * combined_radius {
            if let Some(event) = resolve_player_collision(state, id_a, id_b) {
                events.push(event);
            }
        }
    }

    events
}

/// Resolve collision between two players using momentum-based outcome
fn resolve_player_collision(
    state: &mut GameState,
    id_a: PlayerId,
    id_b: PlayerId,
) -> Option<CollisionEvent> {
    // Get player data (read phase)
    let (pos_a, pos_b, vel_a, vel_b, mass_a, mass_b) = {
        let player_a = state.players.get(&id_a)?;
        let player_b = state.players.get(&id_b)?;
        (
            player_a.position,
            player_b.position,
            player_a.velocity,
            player_b.velocity,
            player_a.mass,
            player_b.mass,
        )
    };

    let delta = pos_b - pos_a;
    let dist = delta.length();

    // Use epsilon check for numerical stability (exact zero is rare but near-zero can cause issues)
    if dist < COLLISION_DISTANCE_EPSILON {
        return None;
    }

    let normal = delta * (1.0 / dist);

    // Calculate approach momentum along collision normal
    let vel_a_toward = vel_a.dot(normal).max(0.0);
    let vel_b_toward = (-vel_b.dot(normal)).max(0.0);

    // With advanced_physics: use physics helpers for accurate momentum calculation
    #[cfg(feature = "advanced_physics")]
    let (momentum_a, momentum_b, _energy_a, _energy_b) = {
        // Use physics helpers for momentum
        let mom_a = momentum_magnitude(mass_a, vel_a) * vel_a_toward / vel_a.length().max(COLLISION_DISTANCE_EPSILON);
        let mom_b = momentum_magnitude(mass_b, vel_b) * vel_b_toward / vel_b.length().max(COLLISION_DISTANCE_EPSILON);
        // Calculate kinetic energy (for future damage scaling)
        let ke_a = kinetic_energy(mass_a, vel_a);
        let ke_b = kinetic_energy(mass_b, vel_b);
        (mom_a, mom_b, ke_a, ke_b)
    };

    #[cfg(not(feature = "advanced_physics"))]
    let (momentum_a, momentum_b) = (mass_a * vel_a_toward, mass_b * vel_b_toward);

    // If neither is moving toward the other, just deflect
    if momentum_a == 0.0 && momentum_b == 0.0 {
        deflect(state, id_a, id_b, normal);
        return None;
    }

    let ratio = if momentum_b == 0.0 {
        f32::INFINITY
    } else {
        momentum_a / momentum_b
    };

    // Determine outcome based on momentum ratio
    if ratio > OVERWHELM_THRESHOLD {
        // A overwhelms B - clean kill
        let mass_gain = (mass_b * ABSORPTION_RATE).min(ABSORPTION_CAP);

        if let Some(player_b) = state.players.get_mut(&id_b) {
            player_b.alive = false;
            player_b.deaths += 1;
            player_b.respawn_timer = RESPAWN_DELAY;
        }
        if let Some(player_a) = state.players.get_mut(&id_a) {
            player_a.kills += 1;
            player_a.mass += mass_gain;
        }

        Some(CollisionEvent::Kill {
            killer_id: id_a,
            victim_id: id_b,
        })
    } else if ratio > DECISIVE_THRESHOLD {
        // A decisively wins - kill with splash damage cost
        let mass_gain = (mass_b * DECISIVE_COLLISION_MASS_GAIN_RATIO).min(ABSORPTION_CAP);

        if let Some(player_b) = state.players.get_mut(&id_b) {
            player_b.alive = false;
            player_b.deaths += 1;
            player_b.respawn_timer = RESPAWN_DELAY;
        }
        if let Some(player_a) = state.players.get_mut(&id_a) {
            player_a.kills += 1;
            player_a.mass = player_a.mass * DECISIVE_COLLISION_WINNER_MASS_RETENTION + mass_gain;
        }

        Some(CollisionEvent::Kill {
            killer_id: id_a,
            victim_id: id_b,
        })
    } else if ratio > 1.0 / DECISIVE_THRESHOLD {
        // Close fight - both survive but lose mass
        deflect(state, id_a, id_b, normal);

        // Winner loses less mass
        if ratio > 1.0 {
            if let Some(p) = state.players.get_mut(&id_a) {
                p.mass *= CLOSE_FIGHT_WINNER_MASS_RETENTION;
            }
            if let Some(p) = state.players.get_mut(&id_b) {
                p.mass *= CLOSE_FIGHT_LOSER_MASS_RETENTION;
            }
        } else {
            if let Some(p) = state.players.get_mut(&id_a) {
                p.mass *= CLOSE_FIGHT_LOSER_MASS_RETENTION;
            }
            if let Some(p) = state.players.get_mut(&id_b) {
                p.mass *= CLOSE_FIGHT_WINNER_MASS_RETENTION;
            }
        }

        // Check for death by minimum mass
        check_min_mass(state, id_a);
        check_min_mass(state, id_b);

        // Calculate collision midpoint and intensity for visual effects
        let collision_position = (pos_a + pos_b) * 0.5;
        let relative_vel = (vel_a - vel_b).length();
        // Normalize intensity: 100 units/s = 0.5, 200+ = 1.0
        let intensity = (relative_vel / COLLISION_INTENSITY_MAX_VELOCITY).min(1.0);

        Some(CollisionEvent::Deflection {
            player_a: id_a,
            player_b: id_b,
            position: collision_position,
            intensity,
        })
    } else if ratio > 1.0 / OVERWHELM_THRESHOLD {
        // B decisively wins
        let mass_gain = (mass_a * DECISIVE_COLLISION_MASS_GAIN_RATIO).min(ABSORPTION_CAP);

        if let Some(player_a) = state.players.get_mut(&id_a) {
            player_a.alive = false;
            player_a.deaths += 1;
            player_a.respawn_timer = RESPAWN_DELAY;
        }
        if let Some(player_b) = state.players.get_mut(&id_b) {
            player_b.kills += 1;
            player_b.mass = player_b.mass * DECISIVE_COLLISION_WINNER_MASS_RETENTION + mass_gain;
        }

        Some(CollisionEvent::Kill {
            killer_id: id_b,
            victim_id: id_a,
        })
    } else {
        // B overwhelms A - clean kill
        let mass_gain = (mass_a * ABSORPTION_RATE).min(ABSORPTION_CAP);

        if let Some(player_a) = state.players.get_mut(&id_a) {
            player_a.alive = false;
            player_a.deaths += 1;
            player_a.respawn_timer = RESPAWN_DELAY;
        }
        if let Some(player_b) = state.players.get_mut(&id_b) {
            player_b.kills += 1;
            player_b.mass += mass_gain;
        }

        Some(CollisionEvent::Kill {
            killer_id: id_b,
            victim_id: id_a,
        })
    }
}

/// Apply elastic deflection between two players
fn deflect(state: &mut GameState, id_a: PlayerId, id_b: PlayerId, normal: Vec2) {
    // Get player data (read phase)
    let (vel_a, vel_b, m_a, m_b, pos_a, pos_b) = {
        let player_a = match state.players.get(&id_a) {
            Some(p) => p,
            None => return,
        };
        let player_b = match state.players.get(&id_b) {
            Some(p) => p,
            None => return,
        };
        (
            player_a.velocity,
            player_b.velocity,
            player_a.mass,
            player_b.mass,
            player_a.position,
            player_b.position,
        )
    };

    let rel_vel = vel_a - vel_b;
    let rel_n = rel_vel.dot(normal);

    // Only deflect if moving toward each other (rel_n >= 0 means approaching)
    if rel_n < 0.0 {
        return;
    }

    // Calculate impulse magnitude using coefficient of restitution
    let j = (-(1.0 + RESTITUTION) * rel_n) / (1.0 / m_a + 1.0 / m_b);
    let impulse = normal * j;

    // Calculate separation
    let (r_a, r_b) = (mass_to_radius(m_a), mass_to_radius(m_b));
    let dist = (pos_a - pos_b).length();
    let overlap = r_a + r_b - dist;
    let sep = if overlap > 0.0 { overlap / 2.0 + 1.0 } else { 0.0 };

    // Apply impulses and separation (write phase)
    if let Some(player_a) = state.players.get_mut(&id_a) {
        player_a.velocity += impulse * (1.0 / m_a);
        if sep > 0.0 {
            player_a.position -= normal * sep;
        }
    }
    if let Some(player_b) = state.players.get_mut(&id_b) {
        player_b.velocity -= impulse * (1.0 / m_b);
        if sep > 0.0 {
            player_b.position += normal * sep;
        }
    }
}

/// Check if player mass is below minimum and kill if so
fn check_min_mass(state: &mut GameState, id: PlayerId) {
    if let Some(player) = state.players.get_mut(&id) {
        if player.mass < MINIMUM {
            player.alive = false;
            player.deaths += 1;
            player.respawn_timer = RESPAWN_DELAY;
        }
    }
}

/// Handle player-projectile collisions
fn update_projectile_collisions(state: &mut GameState) -> Vec<CollisionEvent> {
    let mut events = Vec::new();
    let mut projectiles_to_remove = Vec::new();
    let mut mass_gains: Vec<(PlayerId, f32)> = Vec::new();

    for (proj_idx, projectile) in state.projectiles.iter().enumerate() {
        let proj_radius = mass_to_radius(projectile.mass);
        let proj_pos = projectile.position;
        let proj_id = projectile.id;
        let proj_mass = projectile.mass;
        let owner_id = projectile.owner_id;
        let lifetime = projectile.lifetime;

        for player in state.players.values() {
            if !player.alive {
                continue;
            }

            // Can't absorb own projectile immediately
            if player.id == owner_id && lifetime > PROJECTILE_OWNER_ABSORPTION_LIFETIME_THRESHOLD {
                continue;
            }

            let player_radius = mass_to_radius(player.mass);
            // Use squared distance to avoid sqrt()
            let dist_sq = player.position.distance_sq_to(proj_pos);
            let combined_radius = player_radius + proj_radius;

            if dist_sq < combined_radius * combined_radius {
                // Player absorbs projectile
                let mass_gain = proj_mass.min(ABSORPTION_CAP);
                mass_gains.push((player.id, mass_gain));

                events.push(CollisionEvent::ProjectileAbsorbed {
                    player_id: player.id,
                    projectile_id: proj_id,
                    mass_gained: mass_gain,
                });

                projectiles_to_remove.push(proj_idx);
                break;
            }
        }
    }

    // Apply mass gains
    for (player_id, gain) in mass_gains {
        if let Some(player) = state.players.get_mut(&player_id) {
            player.mass += gain;
        }
    }

    // Remove absorbed projectiles (in reverse order to maintain indices)
    for idx in projectiles_to_remove.into_iter().rev() {
        state.projectiles.swap_remove(idx);
    }

    events
}

/// Handle player-debris collisions using spatial grid for O(n) performance
/// Previously O(D × P), now O(D + P) with spatial hashing
fn update_debris_collisions(state: &mut GameState) -> Vec<CollisionEvent> {
    use hashbrown::HashSet;

    let mut events = Vec::new();
    let mut debris_to_remove = HashSet::new();
    let mut mass_gains: Vec<(PlayerId, f32)> = Vec::new();

    // Build spatial grid with debris (O(D))
    // Cell size of 32 units - debris is small (radius 4-11)
    let mut grid = SpatialGrid::new(DEBRIS_COLLISION_GRID_CELL_SIZE);

    // Store debris info indexed by ID for quick lookup after spatial query
    let debris_info: hashbrown::HashMap<u64, (usize, f32, f32)> = state
        .debris
        .iter()
        .enumerate()
        .map(|(idx, d)| {
            let radius = d.radius();
            grid.insert(SpatialEntity {
                id: SpatialEntityId::Debris(d.id),
                position: d.position,
                radius,
            });
            (d.id, (idx, d.mass(), radius))
        })
        .collect();

    // For each player, query nearby debris from spatial grid (O(P × avg_nearby))
    for player in state.players.values() {
        if !player.alive {
            continue;
        }

        let player_radius = mass_to_radius(player.mass);
        // Query radius = player radius + max debris radius (11 for large)
        let query_radius = player_radius + DEBRIS_QUERY_MAX_RADIUS;

        for nearby in grid.query_radius(player.position, query_radius) {
            if let SpatialEntityId::Debris(debris_id) = nearby.id {
                // Skip already collected debris
                if debris_to_remove.contains(&debris_id) {
                    continue;
                }

                if let Some(&(_idx, debris_mass, debris_radius)) = debris_info.get(&debris_id) {
                    let combined_radius = player_radius + debris_radius;
                    let dist_sq = player.position.distance_sq_to(nearby.position);

                    if dist_sq < combined_radius * combined_radius {
                        // Player collects debris
                        mass_gains.push((player.id, debris_mass));

                        events.push(CollisionEvent::DebrisCollected {
                            player_id: player.id,
                            debris_id,
                            mass_gained: debris_mass,
                        });

                        debris_to_remove.insert(debris_id);
                    }
                }
            }
        }
    }

    // Apply mass gains
    for (player_id, gain) in mass_gains {
        if let Some(player) = state.players.get_mut(&player_id) {
            player.mass += gain;
        }
    }

    // Collect indices to remove and sort in descending order for swap_remove
    let mut indices: Vec<usize> = debris_to_remove
        .iter()
        .filter_map(|id| debris_info.get(id).map(|(idx, _, _)| *idx))
        .collect();
    indices.sort_unstable_by(|a, b| b.cmp(a));

    // Remove collected debris using swap_remove for O(1) per removal
    for idx in indices {
        if idx < state.debris.len() {
            state.debris.swap_remove(idx);
        }
    }

    events
}

/// Calculate radius from mass
#[inline]
pub fn mass_to_radius(mass: f32) -> f32 {
    mass.sqrt() * RADIUS_SCALE
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::game::state::{DebrisSize, Player};

    fn create_player(name: &str, position: Vec2, velocity: Vec2, mass: f32) -> Player {
        Player {
            id: uuid::Uuid::new_v4(),
            name: name.to_string(),
            position,
            velocity,
            rotation: 0.0,
            mass,
            alive: true,
            kills: 0,
            deaths: 0,
            spawn_protection: 0.0,
            is_bot: false,
            color_index: 0,
            respawn_timer: 0.0,
            spawn_tick: 0,
        }
    }

    #[test]
    fn test_no_collision_when_far_apart() {
        let mut state = GameState::new();
        let p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::ZERO, 100.0);
        let p2 = create_player("B", Vec2::new(1000.0, 0.0), Vec2::ZERO, 100.0);
        let id1 = p1.id;
        let id2 = p2.id;
        state.add_player(p1);
        state.add_player(p2);

        let events = update(&mut state);

        assert!(events.is_empty());
        assert!(state.get_player(id1).unwrap().alive);
        assert!(state.get_player(id2).unwrap().alive);
    }

    #[test]
    fn test_overwhelm_collision() {
        let mut state = GameState::new();

        // Player A: heavy and moving fast toward B
        let p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(200.0, 0.0), 200.0);
        let _id1 = p1.id;
        state.add_player(p1);

        // Player B: light and stationary
        let p2 = create_player("B", Vec2::new(30.0, 0.0), Vec2::ZERO, 50.0);
        let _id2 = p2.id;
        state.add_player(p2);

        let events = update(&mut state);

        assert!(events.iter().any(|e| matches!(e, CollisionEvent::Kill { .. })));
        // Check that one survived and one died (order may vary with HashMap)
        let alive_count = state.players.values().filter(|p| p.alive).count();
        assert_eq!(alive_count, 1);
    }

    #[test]
    fn test_spawn_protection_prevents_collision() {
        let mut state = GameState::new();

        let mut p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), 200.0);
        p1.spawn_protection = 3.0;
        let id1 = p1.id;
        state.add_player(p1);

        let p2 = create_player("B", Vec2::new(30.0, 0.0), Vec2::ZERO, 50.0);
        let id2 = p2.id;
        state.add_player(p2);

        let events = update(&mut state);

        assert!(events.is_empty());
        assert!(state.get_player(id1).unwrap().alive);
        assert!(state.get_player(id2).unwrap().alive);
    }

    #[test]
    fn test_deflection_both_survive() {
        let mut state = GameState::new();

        // Two equal players moving toward each other at same speed
        let p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(50.0, 0.0), 100.0);
        state.add_player(p1);

        let p2 = create_player("B", Vec2::new(30.0, 0.0), Vec2::new(-50.0, 0.0), 100.0);
        state.add_player(p2);

        let events = update(&mut state);

        // Should be a deflection, both survive (or mass loss causes death)
        assert!(events
            .iter()
            .any(|e| matches!(e, CollisionEvent::Deflection { .. })));
    }

    #[test]
    fn test_projectile_absorption() {
        let mut state = GameState::new();

        let player = create_player("A", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let player_id = player.id;
        state.add_player(player);

        // Add projectile from different owner at same position
        state.add_projectile(
            uuid::Uuid::new_v4(), // Different owner
            Vec2::new(100.0, 100.0),
            Vec2::ZERO,
            20.0,
        );
        // Set lifetime lower so it can be absorbed
        state.projectiles[0].lifetime = 5.0;

        let initial_mass = state.get_player(player_id).unwrap().mass;
        let events = update(&mut state);

        assert!(events
            .iter()
            .any(|e| matches!(e, CollisionEvent::ProjectileAbsorbed { .. })));
        assert!(state.projectiles.is_empty());
        assert!(state.get_player(player_id).unwrap().mass > initial_mass);
    }

    #[test]
    fn test_own_projectile_not_absorbed_immediately() {
        let mut state = GameState::new();

        let player = create_player("A", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let player_id = player.id;
        state.add_player(player);

        // Add projectile from same owner with high lifetime
        state.add_projectile(player_id, Vec2::new(100.0, 100.0), Vec2::ZERO, 20.0);

        let events = update(&mut state);

        // Should not absorb own fresh projectile
        assert!(!events
            .iter()
            .any(|e| matches!(e, CollisionEvent::ProjectileAbsorbed { .. })));
    }

    #[test]
    fn test_debris_collection() {
        let mut state = GameState::new();

        let player = create_player("A", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let player_id = player.id;
        state.add_player(player);

        state.add_debris(Vec2::new(100.0, 100.0), Vec2::ZERO, DebrisSize::Medium);

        let initial_mass = state.get_player(player_id).unwrap().mass;
        let events = update(&mut state);

        assert!(events
            .iter()
            .any(|e| matches!(e, CollisionEvent::DebrisCollected { .. })));
        assert!(state.debris.is_empty());
        assert!(state.get_player(player_id).unwrap().mass > initial_mass);
    }

    #[test]
    fn test_mass_to_radius() {
        let mass = 100.0;
        let radius = mass_to_radius(mass);
        let expected = (100.0_f32).sqrt() * RADIUS_SCALE;

        assert!((radius - expected).abs() < 0.001);
    }

    #[test]
    fn test_dead_players_ignored() {
        let mut state = GameState::new();

        let mut p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), 200.0);
        p1.alive = false;
        state.add_player(p1);

        state.add_player(create_player(
            "B",
            Vec2::new(30.0, 0.0),
            Vec2::ZERO,
            100.0,
        ));

        let events = update(&mut state);

        assert!(events.is_empty());
    }

    #[test]
    fn test_deflect_approaching_players_bounce() {
        // Two players approaching each other should have their velocities changed
        let mut state = GameState::new();

        // Player A moving right toward B
        let p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), 100.0);
        let id1 = p1.id;
        state.add_player(p1);

        // Player B moving left toward A
        let p2 = create_player("B", Vec2::new(25.0, 0.0), Vec2::new(-100.0, 0.0), 100.0);
        let id2 = p2.id;
        state.add_player(p2);

        let vel_a_before = state.get_player(id1).unwrap().velocity;
        let vel_b_before = state.get_player(id2).unwrap().velocity;

        let _events = update(&mut state);

        // Velocities should have changed (deflection occurred)
        let vel_a_after = state.get_player(id1).unwrap().velocity;
        let vel_b_after = state.get_player(id2).unwrap().velocity;

        // After deflection, velocities should be different
        assert!(
            (vel_a_after.x - vel_a_before.x).abs() > 1.0 ||
            (vel_b_after.x - vel_b_before.x).abs() > 1.0,
            "Velocities should change after deflection"
        );
    }

    #[test]
    fn test_deflect_stationary_player_hit() {
        // Moving player hits stationary player
        let mut state = GameState::new();

        let p1 = create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), 100.0);
        let id1 = p1.id;
        state.add_player(p1);

        let p2 = create_player("B", Vec2::new(20.0, 0.0), Vec2::ZERO, 100.0);
        let id2 = p2.id;
        state.add_player(p2);

        let vel_b_before = state.get_player(id2).unwrap().velocity;

        let normal = Vec2::new(1.0, 0.0);
        deflect(&mut state, id1, id2, normal);

        let vel_b_after = state.get_player(id2).unwrap().velocity;

        // B should gain velocity from the impact
        assert!(
            vel_b_after.x > vel_b_before.x,
            "Stationary player should gain velocity"
        );
    }

    #[test]
    fn test_collision_at_angle() {
        // Test collision at 45 degree angle
        let mut state = GameState::new();

        state.add_player(create_player("A", Vec2::new(0.0, 0.0), Vec2::new(70.7, 70.7), 100.0));
        state.add_player(create_player("B", Vec2::new(15.0, 15.0), Vec2::ZERO, 100.0));

        let events = update(&mut state);

        // Should trigger some collision event (or velocities changed)
        let any_collision = !events.is_empty();
        assert!(any_collision || state.players.values().any(|p| p.velocity.length() != 0.0 || p.velocity.length() != 100.0));
    }

    #[test]
    fn test_multiple_simultaneous_collisions() {
        // Test that multiple collisions in same frame work correctly
        let mut state = GameState::new();

        state.add_player(create_player("A", Vec2::new(0.0, 0.0), Vec2::new(50.0, 0.0), 100.0));
        state.add_player(create_player("B", Vec2::new(25.0, 0.0), Vec2::ZERO, 100.0));
        state.add_player(create_player("C", Vec2::new(50.0, 0.0), Vec2::new(-50.0, 0.0), 100.0));

        let _events = update(&mut state);

        // At minimum, the collision system shouldn't crash
        assert!(state.players.values().filter(|p| p.alive).count() >= 1);
    }

    #[test]
    fn test_zero_distance_collision_handled() {
        // Edge case: two players at exact same position
        let mut state = GameState::new();

        state.add_player(create_player("A", Vec2::new(100.0, 100.0), Vec2::new(10.0, 0.0), 100.0));
        state.add_player(create_player("B", Vec2::new(100.0, 100.0), Vec2::new(-10.0, 0.0), 100.0));

        // Should not panic
        let _events = update(&mut state);

        // System should handle this gracefully - at least one survives
        assert!(state.players.values().any(|p| p.alive));
    }

    #[test]
    fn test_very_high_velocity_collision() {
        // Edge case: extremely high velocity collision
        let mut state = GameState::new();

        state.add_player(create_player("A", Vec2::new(0.0, 0.0), Vec2::new(10000.0, 0.0), 100.0));
        state.add_player(create_player("B", Vec2::new(25.0, 0.0), Vec2::new(-10000.0, 0.0), 100.0));

        // Should not panic or produce NaN
        let _events = update(&mut state);

        for player in state.players.values() {
            assert!(!player.velocity.x.is_nan() && !player.velocity.y.is_nan());
        }
    }

    #[test]
    fn test_collision_with_very_small_mass() {
        // Edge case: very small mass (near minimum)
        let mut state = GameState::new();

        state.add_player(create_player("A", Vec2::new(0.0, 0.0), Vec2::new(100.0, 0.0), MINIMUM + 1.0));
        state.add_player(create_player("B", Vec2::new(20.0, 0.0), Vec2::new(-100.0, 0.0), MINIMUM + 1.0));

        // Should not panic
        let _events = update(&mut state);
        assert!(true);
    }

    #[test]
    fn test_projectile_from_dead_player_can_be_absorbed() {
        let mut state = GameState::new();
        let dead_player_id = uuid::Uuid::new_v4();

        let player = create_player("Alive", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let _player_id = player.id;
        state.add_player(player);

        state.add_projectile(dead_player_id, Vec2::new(100.0, 100.0), Vec2::ZERO, 20.0);
        state.projectiles[0].lifetime = 1.0;

        let events = update(&mut state);

        assert!(events.iter().any(|e| matches!(e, CollisionEvent::ProjectileAbsorbed { .. })));
        assert!(state.projectiles.is_empty());
    }

    #[test]
    fn test_multiple_debris_collection_same_frame() {
        let mut state = GameState::new();

        let player = create_player("A", Vec2::new(100.0, 100.0), Vec2::ZERO, 100.0);
        let player_id = player.id;
        state.add_player(player);

        state.add_debris(Vec2::new(100.0, 100.0), Vec2::ZERO, DebrisSize::Small);
        state.add_debris(Vec2::new(100.0, 100.0), Vec2::ZERO, DebrisSize::Small);
        state.add_debris(Vec2::new(100.0, 100.0), Vec2::ZERO, DebrisSize::Small);

        let initial_mass = state.get_player(player_id).unwrap().mass;
        let events = update(&mut state);

        let collections = events.iter().filter(|e| matches!(e, CollisionEvent::DebrisCollected { .. })).count();
        assert!(collections >= 1);
        assert!(state.get_player(player_id).unwrap().mass > initial_mass);
    }
}
