//! Game loop and tick processing
//!
//! Manages the core game simulation at fixed timestep.

#![allow(dead_code)] // Config fields and event data

use std::collections::HashMap;
use std::time::{Duration, Instant};
use uuid::Uuid;

use crate::config::{ArenaScalingConfig, DebrisSpawnConfig, GravityConfig, GravityWaveConfig};
use crate::game::constants::physics::{DT, TICK_RATE};
use crate::game::match_result::{check_match_end, determine_result, MatchEndReason, MatchResult};
use crate::game::state::{GameState, MatchPhase, PlayerId, WellId};
use crate::game::systems::{ai, arena, collision, debris, gravity, physics, projectile};
use crate::net::protocol::PlayerInput;
use crate::util::vec2::Vec2;

/// Events generated by the game loop
#[derive(Debug)]
pub enum GameLoopEvent {
    /// Game state was updated
    Tick { tick: u64 },
    /// Match phase changed
    PhaseChange { phase: MatchPhase, countdown: f32 },
    /// Player was killed
    PlayerKilled {
        killer_id: PlayerId,
        victim_id: PlayerId,
    },
    /// Match ended
    MatchEnded { result: MatchResult },
    /// Zone collapsed
    ZoneCollapse { phase: u8, new_radius: f32 },
    /// Players collided and deflected (both survived)
    PlayerDeflection {
        player_a: PlayerId,
        player_b: PlayerId,
        position: Vec2,
        intensity: f32,
    },
    /// A gravity well started charging (warning before explosion)
    GravityWellCharging {
        well_id: WellId,
        position: Vec2,
    },
    /// A gravity well exploded, creating an expanding wave
    GravityWaveExplosion {
        well_id: WellId,
        position: Vec2,
        strength: f32,
    },
    /// A gravity well was destroyed (removed from arena after explosion)
    GravityWellDestroyed {
        well_id: WellId,
        position: Vec2,
    },
}

/// Configuration for the game loop
#[derive(Debug, Clone)]
pub struct GameLoopConfig {
    pub tick_rate: u32,
    pub enable_inter_entity_gravity: bool,
    pub gravity_config: GravityConfig,
    pub gravity_wave_config: GravityWaveConfig,
    pub debris_spawn_config: DebrisSpawnConfig,
    pub arena_scaling_config: ArenaScalingConfig,
}

impl Default for GameLoopConfig {
    fn default() -> Self {
        Self {
            tick_rate: TICK_RATE,
            enable_inter_entity_gravity: false,
            gravity_config: GravityConfig::default(),
            gravity_wave_config: GravityWaveConfig::default(),
            debris_spawn_config: DebrisSpawnConfig::default(),
            arena_scaling_config: ArenaScalingConfig::default(),
        }
    }
}

/// Game loop manager
pub struct GameLoop {
    config: GameLoopConfig,
    state: GameState,
    ai_manager: ai::AiManager,
    charge_manager: projectile::ChargeManager,
    debris_spawn_state: debris::DebrisSpawnState,
    pending_inputs: HashMap<PlayerId, Vec<PlayerInput>>,
    last_tick_time: Instant,
    accumulator: Duration,
}

impl GameLoop {
    pub fn new(config: GameLoopConfig) -> Self {
        Self {
            config,
            state: GameState::new(),
            ai_manager: ai::AiManager::new(),
            charge_manager: projectile::ChargeManager::new(),
            debris_spawn_state: debris::DebrisSpawnState::new(),
            pending_inputs: HashMap::new(),
            last_tick_time: Instant::now(),
            accumulator: Duration::ZERO,
        }
    }

    /// Get gravity wave config
    pub fn gravity_wave_config(&self) -> &GravityWaveConfig {
        &self.config.gravity_wave_config
    }

    /// Get current game state
    pub fn state(&self) -> &GameState {
        &self.state
    }

    /// Get mutable game state
    pub fn state_mut(&mut self) -> &mut GameState {
        &mut self.state
    }

    /// Queue player input for processing
    pub fn queue_input(&mut self, player_id: PlayerId, input: PlayerInput) {
        self.pending_inputs
            .entry(player_id)
            .or_default()
            .push(input);
    }

    /// Process accumulated time and run ticks
    pub fn update(&mut self) -> Vec<GameLoopEvent> {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_tick_time);
        self.last_tick_time = now;
        self.accumulator += elapsed;

        let tick_duration = Duration::from_secs_f32(DT);
        let mut events = Vec::new();

        while self.accumulator >= tick_duration {
            self.accumulator -= tick_duration;
            events.extend(self.tick());
        }

        events
    }

    /// Run a single game tick
    pub fn tick(&mut self) -> Vec<GameLoopEvent> {
        let mut events = Vec::new();

        // Update match phase
        if let Some(phase_event) = self.update_match_phase() {
            events.push(phase_event);
        }

        // Only process game logic during playing phase
        if self.state.match_state.phase != MatchPhase::Playing {
            self.state.tick += 1;
            return events;
        }

        // Process player inputs
        self.process_inputs();

        // Update AI
        self.ai_manager.update(&self.state, DT);
        self.process_ai_inputs();

        // Run physics systems
        gravity::update_central_with_config(&mut self.state, &self.config.gravity_config, DT);
        if self.config.enable_inter_entity_gravity {
            gravity::update_inter_entity(&mut self.state, DT);
        }
        physics::update(&mut self.state, DT);

        // Update gravity wave explosions (occasional random events)
        // Only if feature is enabled via config
        if self.config.gravity_wave_config.enabled {
            // Calculate target wells based on arena area (not player count)
            let escape_radius = self.state.arena.escape_radius;
            let arena_area = std::f32::consts::PI * escape_radius * escape_radius;
            let config = &self.config.arena_scaling_config;
            let target_wells = ((arena_area / config.wells_per_area).ceil() as usize)
                .max(config.min_wells);

            let wave_events = gravity::update_explosions(
                &mut self.state,
                &self.config.gravity_wave_config,
                DT,
                target_wells,
            );
            for event in wave_events {
                match event {
                    gravity::GravityWaveEvent::WellCharging { well_id, position } => {
                        events.push(GameLoopEvent::GravityWellCharging { well_id, position });
                    }
                    gravity::GravityWaveEvent::WellExploded { well_id, position, strength } => {
                        events.push(GameLoopEvent::GravityWaveExplosion { well_id, position, strength });
                    }
                    gravity::GravityWaveEvent::WellDestroyed { well_id, position } => {
                        events.push(GameLoopEvent::GravityWellDestroyed { well_id, position });
                        tracing::debug!("Well {} destroyed at {:?}", well_id, position);
                    }
                }
            }
            // Update active gravity waves (expanding and pushing players)
            gravity::update_waves(&mut self.state, &self.config.gravity_wave_config, DT);
        }

        // Run collision system
        let collision_events = collision::update(&mut self.state);
        for event in collision_events {
            match event {
                collision::CollisionEvent::Kill { killer_id, victim_id } => {
                    events.push(GameLoopEvent::PlayerKilled { killer_id, victim_id });
                }
                collision::CollisionEvent::Deflection { player_a, player_b, position, intensity } => {
                    events.push(GameLoopEvent::PlayerDeflection {
                        player_a,
                        player_b,
                        position,
                        intensity,
                    });
                }
                _ => {} // ProjectileAbsorbed, DebrisCollected - no visual event needed
            }
        }

        // Run arena system
        let arena_events = arena::update(&mut self.state, DT);
        for event in arena_events {
            if let arena::ArenaEvent::CollapseStarted { phase, new_safe_radius } = event {
                events.push(GameLoopEvent::ZoneCollapse {
                    phase,
                    new_radius: new_safe_radius,
                });
            }
        }

        // Spawn new debris over time (if enabled)
        debris::update(
            &mut self.state,
            &self.config.debris_spawn_config,
            &mut self.debris_spawn_state,
            DT,
        );

        // Spawn debris around gravity wells (feeding zones)
        debris::update_well_spawning(
            &mut self.state,
            &self.config.debris_spawn_config,
            &mut self.debris_spawn_state.well_accumulator,
            DT,
        );

        // Update match time
        self.state.match_state.match_time += DT;

        // Check for match end
        if let Some(reason) = check_match_end(&self.state) {
            self.end_match(reason);
            let result = determine_result(&self.state);
            events.push(GameLoopEvent::MatchEnded { result });
        }

        self.state.tick += 1;
        events.push(GameLoopEvent::Tick {
            tick: self.state.tick,
        });

        events
    }

    /// Process pending player inputs
    fn process_inputs(&mut self) {
        let inputs: Vec<(PlayerId, Vec<PlayerInput>)> =
            self.pending_inputs.drain().collect();

        for (player_id, player_inputs) in inputs {
            // Process most recent input (could implement input buffer here)
            if let Some(input) = player_inputs.into_iter().last() {
                physics::apply_thrust(&mut self.state, player_id, &input, DT);
                projectile::process_input(
                    &mut self.state,
                    player_id,
                    &input,
                    &mut self.charge_manager,
                    DT,
                );
            }
        }
    }

    /// Process AI inputs
    fn process_ai_inputs(&mut self) {
        let tick = self.state.tick;

        // Collect bot player IDs first to avoid borrow issues
        let bot_ids: Vec<PlayerId> = self
            .state
            .players
            .values()
            .filter(|p| p.is_bot && p.alive)
            .map(|p| p.id)
            .collect();

        for player_id in bot_ids {
            if let Some(input) = self.ai_manager.get_input(player_id, tick) {
                physics::apply_thrust(&mut self.state, player_id, &input, DT);
                projectile::process_input(
                    &mut self.state,
                    player_id,
                    &input,
                    &mut self.charge_manager,
                    DT,
                );
            }
        }
    }

    /// Update match phase (countdown, etc.)
    fn update_match_phase(&mut self) -> Option<GameLoopEvent> {
        match self.state.match_state.phase {
            MatchPhase::Waiting => {
                // Check if enough players
                if self.state.players.len() >= crate::game::constants::game::MIN_PLAYERS {
                    self.state.match_state.phase = MatchPhase::Countdown;
                    self.state.match_state.countdown_time = crate::game::constants::game::COUNTDOWN;
                    return Some(GameLoopEvent::PhaseChange {
                        phase: MatchPhase::Countdown,
                        countdown: self.state.match_state.countdown_time,
                    });
                }
            }
            MatchPhase::Countdown => {
                self.state.match_state.countdown_time -= DT;
                if self.state.match_state.countdown_time <= 0.0 {
                    self.state.match_state.phase = MatchPhase::Playing;
                    self.state.match_state.match_time = 0.0;

                    // Spawn initial debris when match starts
                    debris::spawn_initial(&mut self.state, &self.config.debris_spawn_config);
                    // Spawn debris around gravity wells (feeding zones)
                    debris::spawn_around_wells(&mut self.state, &self.config.debris_spawn_config);

                    return Some(GameLoopEvent::PhaseChange {
                        phase: MatchPhase::Playing,
                        countdown: 0.0,
                    });
                }
            }
            MatchPhase::Playing => {}
            MatchPhase::Ended => {}
        }
        None
    }

    /// End the match
    fn end_match(&mut self, _reason: MatchEndReason) {
        self.state.match_state.phase = MatchPhase::Ended;
        let result = determine_result(&self.state);
        self.state.match_state.winner_id = result.winner_id;
    }

    /// Add a player to the game
    pub fn add_player(&mut self, mut player: crate::game::state::Player) -> PlayerId {
        let id = player.id;

        // Collect existing player positions for safe spawn
        let existing_positions: Vec<_> = self
            .state
            .players
            .values()
            .filter(|p| p.alive)
            .map(|p| p.position)
            .collect();

        // Assign safe spawn position near a gravity well, away from other players
        let wells: Vec<_> = self.state.arena.gravity_wells.values().cloned().collect();
        player.position = arena::safe_spawn_near_well(&wells, &existing_positions);

        // Use orbital velocity relative to nearest well
        player.velocity = arena::spawn_velocity_for_well(player.position, &wells);

        self.state.add_player(player.clone());

        if player.is_bot {
            self.ai_manager.register_bot(id);
        }

        id
    }

    /// Remove a player from the game
    pub fn remove_player(&mut self, player_id: PlayerId) -> Option<crate::game::state::Player> {
        self.ai_manager.unregister_bot(player_id);
        self.charge_manager.remove(player_id);
        self.pending_inputs.remove(&player_id);
        self.state.remove_player(player_id)
    }

    /// Reset charge state for a player (e.g., on respawn)
    pub fn reset_charge(&mut self, player_id: PlayerId) {
        self.charge_manager.reset(player_id);
    }

    /// Add AI bots to fill the game
    /// Uses same spawn mechanics as human players (add_player handles positioning)
    pub fn fill_with_bots(&mut self, total_players: usize) {
        let current_count = self.state.players.len();
        if current_count >= total_players {
            return;
        }

        let bots_needed = total_players - current_count;

        for i in 0..bots_needed {
            // Use Player::new like humans - add_player handles spawn position
            let bot = crate::game::state::Player::new(
                Uuid::new_v4(),
                ai::generate_bot_name(),
                true, // is_bot
                (current_count + i) as u8,
            );
            self.add_player(bot);
        }
    }

    /// Reset the game for a new match
    pub fn reset(&mut self) {
        self.state = GameState::new();
        self.ai_manager = ai::AiManager::new();
        self.charge_manager = projectile::ChargeManager::new();
        self.debris_spawn_state = debris::DebrisSpawnState::new();
        self.pending_inputs.clear();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::game::state::Player;
    use crate::util::vec2::Vec2;

    fn create_player(name: &str, is_bot: bool) -> Player {
        Player {
            id: Uuid::new_v4(),
            name: name.to_string(),
            position: Vec2::new(300.0, 0.0),
            velocity: Vec2::ZERO,
            rotation: 0.0,
            mass: 100.0,
            alive: true,
            kills: 0,
            deaths: 0,
            spawn_protection: 0.0,
            is_bot,
            color_index: 0,
            respawn_timer: 0.0,
        }
    }

    #[test]
    fn test_game_loop_new() {
        let game_loop = GameLoop::new(GameLoopConfig::default());
        assert_eq!(game_loop.state().tick, 0);
        assert_eq!(game_loop.state().match_state.phase, MatchPhase::Waiting);
    }

    #[test]
    fn test_add_player() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        let player = create_player("Test", false);
        let id = player.id;

        game_loop.add_player(player);

        assert!(game_loop.state().get_player(id).is_some());
    }

    #[test]
    fn test_remove_player() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        let player = create_player("Test", false);
        let id = player.id;

        game_loop.add_player(player);
        let removed = game_loop.remove_player(id);

        assert!(removed.is_some());
        assert!(game_loop.state().get_player(id).is_none());
    }

    #[test]
    fn test_fill_with_bots() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        game_loop.add_player(create_player("Human", false));

        game_loop.fill_with_bots(5);

        assert_eq!(game_loop.state().players.len(), 5);
        // 1 human + 4 bots
        let bot_count = game_loop.state().players.values().filter(|p| p.is_bot).count();
        assert_eq!(bot_count, 4);
    }

    #[test]
    fn test_phase_transition_to_countdown() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        game_loop.add_player(create_player("P1", false));
        game_loop.add_player(create_player("P2", false));

        let events = game_loop.tick();

        assert!(events.iter().any(|e| matches!(
            e,
            GameLoopEvent::PhaseChange {
                phase: MatchPhase::Countdown,
                ..
            }
        )));
    }

    #[test]
    fn test_tick_increments() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        game_loop.state_mut().match_state.phase = MatchPhase::Playing;

        let initial_tick = game_loop.state().tick;
        game_loop.tick();

        assert_eq!(game_loop.state().tick, initial_tick + 1);
    }

    #[test]
    fn test_queue_input() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        let player = create_player("Test", false);
        let player_id = player.id;
        game_loop.add_player(player);

        let input = PlayerInput {
            sequence: 1,
            tick: 1,
            thrust: Vec2::new(1.0, 0.0),
            boost: true,
            ..Default::default()
        };

        game_loop.queue_input(player_id, input);

        // Input should be pending
        assert!(game_loop.pending_inputs.contains_key(&player_id));
    }

    #[test]
    fn test_reset() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        game_loop.add_player(create_player("P1", false));
        game_loop.state_mut().tick = 100;

        game_loop.reset();

        assert_eq!(game_loop.state().tick, 0);
        assert!(game_loop.state().players.is_empty());
    }

    #[test]
    fn test_player_gets_spawn_position() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        let mut player = create_player("Test", false);
        player.position = Vec2::ZERO;

        game_loop.add_player(player.clone());

        // Position should have been updated
        let added = game_loop.state().get_player(player.id).unwrap();
        assert!(added.position.length() > 0.0);
    }

    #[test]
    fn test_reset_charge_on_respawn() {
        let mut game_loop = GameLoop::new(GameLoopConfig::default());
        let player = create_player("Test", false);
        let player_id = player.id;
        game_loop.add_player(player);

        // Start charging by processing fire input
        let fire_input = PlayerInput {
            sequence: 1,
            tick: 1,
            fire: true,
            aim: Vec2::new(1.0, 0.0),
            ..Default::default()
        };
        game_loop.queue_input(player_id, fire_input.clone());
        game_loop.state_mut().match_state.phase = MatchPhase::Playing;
        game_loop.tick();

        // Process several more charging ticks
        for i in 2..5 {
            game_loop.queue_input(
                player_id,
                PlayerInput {
                    sequence: i,
                    tick: i,
                    fire: true,
                    aim: Vec2::new(1.0, 0.0),
                    ..Default::default()
                },
            );
            game_loop.tick();
        }

        // Verify charge state exists (implicitly via reset not panicking)
        // Reset charge state (simulates respawn)
        game_loop.reset_charge(player_id);

        // Now send fire_released - should NOT fire a projectile since charge was reset
        let release_input = PlayerInput {
            sequence: 10,
            tick: 10,
            fire: false,
            fire_released: true,
            aim: Vec2::new(1.0, 0.0),
            ..Default::default()
        };
        game_loop.queue_input(player_id, release_input);
        game_loop.tick();

        // No projectile should have been created (charge was reset)
        assert_eq!(game_loop.state().projectiles.len(), 0);
    }
}
